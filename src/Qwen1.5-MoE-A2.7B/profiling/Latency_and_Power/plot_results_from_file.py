"""
Profiling Results Plotting from File

This script loads profiling results (latency and power consumption per layer) from a text file
generated by either forward_pass_profiling.py or expert_selection_profiling.py. It parses the results
and generates bar plots for GPU/CPU latency and power consumption for each transformer layer group,
saving the plots as SVG and PNG files in the specified output directory.

- Run forward_pass_profiling.py or expert_selection_profiling.py first to generate the profiling data.
- This script reads the output file (e.g., Measurements/forward_pass_profiling.txt or Measurements/expert_selection_profiling.txt).
- It groups layers by Transformer layer index and visualizes latency and power for each group.
- Plots are saved in subdirectories for easy comparison and analysis.
"""

import matplotlib.pyplot as plt
import numpy as np
import re
import os


# Plot results for every layer
def plot_profiling_results(results, output_dir):
    print("Plotting results...")

    # Group layers by decoder layer index
    layer_groups = {}
    for layer_name in results.keys():
        match = re.match(r"model\.layers\.(\d+)\.", layer_name)
        if match:
            layer_idx = int(match.group(1))
            if layer_idx not in layer_groups:
                layer_groups[layer_idx] = []
            layer_groups[layer_idx].append(layer_name)
        elif "model.embed_tokens" in layer_name:
            if 0 not in layer_groups:
                layer_groups[0] = []
            layer_groups[0].append(layer_name)
        elif "model.rotary_emb" in layer_name:
            layer_groups[0].append(layer_name)
        elif "model.norm" in layer_name or "lm_head" in layer_name:
            layer_groups[23].append(layer_name)

    # Plot for each transformer layer group
    for layer_idx, layers in layer_groups.items():
        print(f"Plotting Layer {layer_idx}...")

        # Filter and sort layers for this decoder
        layer_data = [(name, results[name]) for name in layers]

        # Extract metrics
        layer_names = [name for name, _ in layer_data]
        gpu_times = [data["gpu_time"] for _, data in layer_data]
        cpu_times = [data["cpu_time"] for _, data in layer_data]
        gpu_powers = [data["avg_gpu_power"] for _, data in layer_data]
        cpu_powers = [data["avg_cpu_power"] for _, data in layer_data]

        # Calculate dynamic figure size
        n_layers = len(layer_names)
        fig_width = max(12, len(layers) * 0.4)
        fig_height = 8

        # Plot Latency
        fig, ax = plt.subplots(figsize=(fig_width, fig_height))
        x = np.arange(n_layers)
        width = 0.2

        ax.bar(x - width / 2, gpu_times, width, label="GPU Time (ms)")
        ax.bar(x + width / 2, cpu_times, width, label="CPU Time (ms)")

        ax.set_title(f"Decoder Layer {layer_idx} - Latency")
        ax.set_xticks(x)
        ax.set_xticklabels(
            [name.split(f"model.layers.{layer_idx}.")[-1] for name in layer_names],
            rotation=90,
            ha="center",
            fontsize=8,
        )
        ax.legend()
        plt.tight_layout()
        # Ensure output directories exist
        os.makedirs(f"{output_dir}/Latency_Plots/SVG", exist_ok=True)
        os.makedirs(f"{output_dir}/Latency_Plots/PNG", exist_ok=True)
        plt.savefig(f"{output_dir}/Latency_Plots/SVG/layer_{layer_idx}_latency.svg")
        plt.savefig(f"{output_dir}/Latency_Plots/PNG/layer_{layer_idx}_latency.png")
        plt.close()

        # Plot Power
        fig, ax = plt.subplots(figsize=(fig_width, fig_height))

        ax.bar(x - width / 2, gpu_powers, width, label="GPU Power (mW)")
        ax.bar(x + width / 2, cpu_powers, width, label="CPU Power (mW)")

        ax.set_title(f"Decoder Layer {layer_idx} - Power Consumption")
        ax.set_xticks(x)
        ax.set_xticklabels(
            [name.split(f"model.layers.{layer_idx}.")[-1] for name in layer_names],
            rotation=90,
            ha="center",
            fontsize=8,
        )
        ax.legend()
        plt.tight_layout()
        os.makedirs(f"{output_dir}/Power_Plots/SVG", exist_ok=True)
        os.makedirs(f"{output_dir}/Power_Plots/PNG", exist_ok=True)
        plt.savefig(f"{output_dir}/Power_Plots/SVG/layer_{layer_idx}_power.svg")
        plt.savefig(f"{output_dir}/Power_Plots/PNG/layer_{layer_idx}_power.png")
        plt.close()

    print(f"Generated Latency and Power plots for {len(layer_groups)} layers")


def main():
    results = {}
    # Make sure to run forward_pass_profiling.py or expert_selection_profiling.py first to generate the profiling file!
    # file_path = "Measurements/forward_pass_profiling.txt"
    file_path = "Measurements/expert_selection_profiling.txt"
    with open(file_path, "r") as f:
        # Skip header lines until separator
        for line in f:
            if line.startswith("="):
                break

        # Process data lines
        for line in f:
            line = line.strip()
            if not line:
                continue

            # Split columns using regular expression for 2+ spaces
            cols = re.split(r"\s{2,}", line)

            if len(cols) >= 6:
                layer = cols[0].strip()
                results[layer] = {
                    "gpu_time": float(cols[2]),
                    "cpu_time": float(cols[3]),
                    "avg_gpu_power": float(cols[4]),
                    "avg_cpu_power": float(cols[5]),
                }
    # output_dir = "Measurements/Every_Layer"
    output_dir = "Measurements/Experts_Only"
    plot_profiling_results(results, output_dir)


if __name__ == "__main__":
    main()
